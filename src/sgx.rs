//! SGX constants and types.

use byteorder::{LittleEndian, ReadBytesExt};
use hex;
use openssl::hash::{Hasher, MessageDigest};
use std::fmt::{self, Debug, Formatter};
use std::io::{Cursor, Error, ErrorKind, Read, Result};
use std::mem;

use crate::graphene;

// Enclave flags
pub const SGX_FLAGS_INITTED: u64 = 0x0000_0000_0000_0001;
pub const SGX_FLAGS_DEBUG: u64 = 0x0000_0000_0000_0002;
pub const SGX_FLAGS_MODE64BIT: u64 = 0x0000_0000_0000_0004;
pub const SGX_FLAGS_PROVISION_KEY: u64 = 0x0000_0000_0000_0010;
pub const SGX_FLAGS_EINITTOKEN_KEY: u64 = 0x0000_0000_0000_0020;
pub const SGX_FLAGS_KSS: u64 = 0x0000_0000_0000_0080;
pub const SGX_FLAGS_RESERVED: u64 = !(SGX_FLAGS_INITTED
    | SGX_FLAGS_DEBUG
    | SGX_FLAGS_MODE64BIT
    | SGX_FLAGS_PROVISION_KEY
    | SGX_FLAGS_EINITTOKEN_KEY
    | SGX_FLAGS_KSS);

// XSAVE feature request mask
pub const SGX_XFRM_LEGACY: u64 = 0x0000_0000_0000_0003;
pub const SGX_XFRM_AVX: u64 = 0x0000_0000_0000_0006;
pub const SGX_XFRM_AVX512: u64 = 0x0000_0000_0000_00E6;
pub const SGX_XFRM_MPX: u64 = 0x0000_0000_0000_0018;
pub const SGX_XFRM_RESERVED: u64 = !(SGX_XFRM_LEGACY | SGX_XFRM_AVX);

/// Extended SSA frame feature select (future functional extensions).
pub type SgxMiscSelect = u32;

/// Cryptographic key. Usually AES-128-GCM.
pub type SgxKey = [u8; 16];

/// Cryptographic key id (derivation material).
pub type SgxKeyId = [u8; 32];

/// ISV security version number.
pub type SgxIsvSvn = u16;

/// Config security version number (KSS only).
pub type SgxConfigSvn = u16;

/// Config ID (KSS only).
pub type SgxConfigId = [u8; 64];

/// CPU security version number.
pub type SgxCpuSvn = [u8; 16];

/// Service Provider ID (EPID attestation).
pub type SgxSpid = [u8; 16];

/// Quote basename (SPID for EPID quotes).
pub type SgxBasename = [u8; 32];

/// EPID group ID.
pub type SgxEpidGroupId = [u8; 4];

/// Linkability type of an EPID quote.
/// IAS verification reports of quotes generated by the same platform contain the same
/// `epidPseudonym` field if the quotes were generated using linkable signatures.
#[repr(u32)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub enum SgxQuoteSignType {
    UnlinkableSignature = 0,
    LinkableSignature = 1,
}

impl_struct! {
    /// Enclave attributes.
    pub struct SgxAttributes {
        /// Enclave flags.
        pub flags: u64,
        /// XSAVE feature request mask.
        pub xfrm: u64,
    }

    /// Enclave misc select and attributes.
    pub struct SgxMiscAttribute {
        /// Enclave attributes.
        pub secs_attr: SgxAttributes,
        /// Enclave misc select flags.
        pub misc_select: SgxMiscSelect,
    }

    /// Information specifying the target enclave for quote generation.
    /// Layout of this struct up to the `bytes` field matches `sgx_target_info_t` from the SGX SDK.
    pub struct SgxTargetInfo {
        /// MR_ENCLAVE of the target enclave.
        pub mr_enclave: SgxMeasurement,
        /// Attributes of the target enclave.
        pub attributes: SgxAttributes,
        /// Reserved, must be zero.
        pub reserved1: [u8; 2],
        /// Config SVN of the target enclave.
        pub config_svn: SgxConfigSvn,
        /// Misc select of the target enclave.
        pub misc_select: SgxMiscSelect,
        /// Reserved, must be zero.
        pub reserved2: [u8; 8],
        /// Config ID of the target enclave.
        pub config_id: SgxConfigId,
        /// Reserved, must be zero.
        pub reserved3: [u8; 384],
        /// Previous fields serialized.
        bytes: Vec<u8>,
    }

    /// Body of the cryptographic enclave report.
    /// Layout of this struct matches `sgx_report_body_t` from the SGX SDK.
    pub struct SgxReportBody {
        /// CPU security version number.
        pub cpu_svn: SgxCpuSvn,
        /// Misc select of the enclave.
        pub misc_select: SgxMiscSelect,
        /// Reserved.
        pub reserved1: [u8; 12],
        /// ISV extended product ID of the enclave.
        pub isv_ext_prod_id: SgxIsvExtProdId,
        /// Attributes of the enclave.
        pub attributes: SgxAttributes,
        /// Hash of the enclave.
        pub mr_enclave: SgxMeasurement,
        /// Reserved.
        pub reserved2: [u8; 32],
        /// Hash of the public key that signed the enclave.
        pub mr_signer: SgxMeasurement,
        /// Reserved.
        pub reserved3: [u8; 32],
        /// Config ID of the enclave.
        pub config_id: SgxConfigId,
        /// ISV product ID of the enclave.
        pub isv_prod_id: SgxProdId,
        /// ISV security version number of the enclave.
        pub isv_svn: SgxIsvSvn,
        /// Config SVN of the enclave.
        pub config_svn: SgxConfigSvn,
        /// Reserved.
        pub reserved4: [u8; 42],
        /// ISV family ID of the enclave.
        pub isv_family_id: SgxIsvFamilyId,
        /// Custom data specified by the enclave.
        pub report_data: SgxReportData,
    }

    /// Cryptographic enclave report.
    /// Layout of this struct up to the `bytes` field matches `sgx_report_t` from the SGX SDK.
    pub struct SgxReport {
        /// Report body.
        pub body: SgxReportBody,
        /// Report key ID.
        pub key_id: SgxKeyId,
        /// AES-128 CMAC of `body`.
        pub mac: SgxMac,
        /// Previous fields serialized.
        bytes: Vec<u8>,
    }

    /// Body of the enclave quote.
    pub struct SgxQuoteBody {
        /// Quote version.
        pub version: u16,
        /// Quote sign type.
        pub sign_type: u16,
        /// EPID group ID of the platform.
        pub epid_group_id: SgxEpidGroupId,
        /// Quoting Enclave's SVN.
        pub qe_svn: SgxIsvSvn,
        /// Provisioning Certification Enclave's SVN.
        pub pce_svn: SgxIsvSvn,
        /// Extended EPID group ID of the platform.
        pub xeid: u32,
        /// Quote basename.
        pub basename: SgxBasename,
        /// Cryptographic report of the enclave.
        pub report_body: SgxReportBody,
    }
}

/// Enclave quote.
#[derive(Default)]
pub struct SgxQuote {
    /// Quote body.
    pub body: SgxQuoteBody,
    /// Quote signature (absent in quotes embedded in IAS reports).
    pub signature: Option<Vec<u8>>,
    /// The whole quote serialized.
    bytes: Vec<u8>,
}

/// Size of SGX hashes (SHA-256).
pub const SGX_HASH_SIZE: usize = 32;

/// Size of SGX MACs (AES-128-CMAC).
pub const SGX_MAC_SIZE: usize = 16;

/// Size of custom data in enclave report.
pub const SGX_REPORT_DATA_SIZE: usize = 64;

/// Product ID.
pub type SgxProdId = u16;

/// ISV extended product ID.
pub type SgxIsvExtProdId = [u8; 16];

/// ISV family ID.
pub type SgxIsvFamilyId = [u8; 16];

/// Enclave cryptographic measurement.
pub type SgxMeasurement = [u8; SGX_HASH_SIZE];

/// MAC (AES-128-CMAC) data.
pub type SgxMac = [u8; SGX_MAC_SIZE];

/// Custom data in enclave report.
pub type SgxReportData = [u8; SGX_REPORT_DATA_SIZE];

/// Parse hex string as `SgxMeasurement`.
pub fn parse_measurement(hex: &str) -> Result<SgxMeasurement> {
    let mut mr = SgxMeasurement::default();
    let data = hex::decode(hex).map_err(|_| Error::from(ErrorKind::InvalidInput))?;
    if data.len() != mr.len() {
        return Err(Error::from(ErrorKind::InvalidInput));
    }
    mr.copy_from_slice(&data);
    Ok(mr)
}

/// Convert byte slice into `SgxReportData` (extending with zeros if size is less than 64).
pub fn expand_report_data(user_data: &[u8]) -> Result<SgxReportData> {
    let user_data_len = user_data.len();
    if user_data_len > SGX_REPORT_DATA_SIZE {
        return Err(Error::from(ErrorKind::InvalidInput));
    }

    let mut report_data = [0; SGX_REPORT_DATA_SIZE];
    report_data[0..user_data_len].copy_from_slice(user_data);
    Ok(report_data)
}

impl Debug for SgxTargetInfo {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "")?;
        writeln!(f, "mr_enclave       : {}", hex::encode(self.mr_enclave))?;
        writeln!(f, "attributes.flags : {:02x}", self.attributes.flags)?;
        writeln!(f, "attributes.xfrm  : {:02x}", self.attributes.xfrm)?;
        #[cfg(feature = "verbose")]
        writeln!(f, "reserved1        : {}", hex::encode(self.reserved1))?;
        writeln!(f, "config_svn       : {:02x}", self.config_svn)?;
        writeln!(f, "misc_select      : {:02x}", self.misc_select)?;
        #[cfg(feature = "verbose")]
        writeln!(f, "reserved2        : {}", hex::encode(self.reserved2))?;
        write!(f, "config_id        : {}", hex::encode(&self.config_id[..]))?;
        #[cfg(feature = "verbose")]
        write!(
            f,
            "\nreserved3        : {}",
            hex::encode(&self.reserved3[..])
        )?;
        Ok(())
    }
}

impl AsRef<[u8]> for SgxTargetInfo {
    fn as_ref(&self) -> &[u8] {
        &self.bytes
    }
}

impl Into<Vec<u8>> for SgxTargetInfo {
    fn into(self) -> Vec<u8> {
        self.bytes
    }
}

impl SgxTargetInfo {
    /// Returns size of the native SGX target info struct.
    pub fn size_raw() -> usize {
        offset_of!(Self, bytes)
    }

    /// Returns target info deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() != Self::size_raw() {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut info = Self::default();

        info.bytes = bytes.to_owned();
        reader.read_exact(&mut info.mr_enclave)?;
        info.attributes.flags = reader.read_u64::<LittleEndian>()?;
        info.attributes.xfrm = reader.read_u64::<LittleEndian>()?;
        reader.read_exact(&mut info.reserved1)?;
        info.config_svn = reader.read_u16::<LittleEndian>()?;
        info.misc_select = reader.read_u32::<LittleEndian>()?;
        reader.read_exact(&mut info.reserved2)?;
        reader.read_exact(&mut info.config_id)?;
        reader.read_exact(&mut info.reserved3)?;

        Ok(info)
    }

    /// Returns target info of the currently executing enclave.
    pub fn from_enclave() -> Result<Self> {
        Self::from_bytes(&graphene::get_target_info()?)
    }
}

impl Debug for SgxReportBody {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, " cpu_svn          : {}", hex::encode(self.cpu_svn))?;
        writeln!(f, " misc_select      : {:02x}", self.misc_select)?;
        #[cfg(feature = "verbose")]
        writeln!(f, " reserved1        : {}", hex::encode(self.reserved1))?;
        writeln!(
            f,
            " isv_ext_prod_id  : {}",
            hex::encode(self.isv_ext_prod_id)
        )?;
        writeln!(f, " attributes.flags : {:02x}", self.attributes.flags)?;
        writeln!(f, " attributes.xfrm  : {:02x}", self.attributes.xfrm)?;
        writeln!(f, " mr_enclave       : {}", hex::encode(self.mr_enclave))?;
        #[cfg(feature = "verbose")]
        writeln!(f, " reserved2        : {}", hex::encode(self.reserved2))?;
        writeln!(f, " mr_signer        : {}", hex::encode(self.mr_signer))?;
        #[cfg(feature = "verbose")]
        writeln!(f, " reserved3        : {}", hex::encode(self.reserved3))?;
        writeln!(
            f,
            " config_id        : {}",
            hex::encode(&self.config_id[..])
        )?;
        writeln!(f, " isv_prod_id      : {:02x}", self.isv_prod_id)?;
        writeln!(f, " isv_svn          : {:02x}", self.isv_svn)?;
        writeln!(f, " config_svn       : {:02x}", self.config_svn)?;
        #[cfg(feature = "verbose")]
        writeln!(
            f,
            " reserved4        : {}",
            hex::encode(&self.reserved4[..])
        )?;
        writeln!(f, " isv_family_id    : {}", hex::encode(self.isv_family_id))?;
        write!(
            f,
            " report_data      : {}",
            hex::encode(&self.report_data[..])
        )
    }
}

impl SgxReportBody {
    /// Returns report body deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() < mem::size_of::<Self>() {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut body = Self::default();

        reader.read_exact(&mut body.cpu_svn)?;
        body.misc_select = reader.read_u32::<LittleEndian>()?;
        reader.read_exact(&mut body.reserved1)?;
        reader.read_exact(&mut body.isv_ext_prod_id)?;
        body.attributes.flags = reader.read_u64::<LittleEndian>()?;
        body.attributes.xfrm = reader.read_u64::<LittleEndian>()?;
        reader.read_exact(&mut body.mr_enclave)?;
        reader.read_exact(&mut body.reserved2)?;
        reader.read_exact(&mut body.mr_signer)?;
        reader.read_exact(&mut body.reserved3)?;
        reader.read_exact(&mut body.config_id)?;
        body.isv_prod_id = reader.read_u16::<LittleEndian>()?;
        body.isv_svn = reader.read_u16::<LittleEndian>()?;
        body.config_svn = reader.read_u16::<LittleEndian>()?;
        reader.read_exact(&mut body.reserved4)?;
        reader.read_exact(&mut body.isv_family_id)?;
        reader.read_exact(&mut body.report_data)?;

        Ok(body)
    }
}

impl Debug for SgxReport {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "\nreport_body:\n{:?}", self.body)?;
        writeln!(f, "key_id           : {}", hex::encode(self.key_id))?;
        write!(f, "mac              : {}", hex::encode(self.mac))
    }
}

impl AsRef<[u8]> for SgxReport {
    fn as_ref(&self) -> &[u8] {
        &self.bytes
    }
}

impl Into<Vec<u8>> for SgxReport {
    fn into(self) -> Vec<u8> {
        self.bytes
    }
}

impl SgxReport {
    /// Returns size of the native SGX report struct.
    pub fn size_raw() -> usize {
        offset_of!(Self, bytes)
    }

    /// Returns report deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() != Self::size_raw() {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut report = Self::default();

        report.bytes = bytes.to_owned();
        report.body = SgxReportBody::from_bytes(bytes)?;
        reader.set_position(mem::size_of::<SgxReportBody>() as u64);
        reader.read_exact(&mut report.key_id)?;
        reader.read_exact(&mut report.mac)?;

        Ok(report)
    }

    /// Returns report of the currently executing enclave.
    pub fn from_enclave(target_info_bytes: &[u8], user_data: &[u8]) -> Result<Self> {
        Self::from_bytes(&graphene::get_report(target_info_bytes, user_data)?)
    }
}

impl Debug for SgxQuote {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "")?;
        writeln!(f, "version           : {:02x}", self.body.version)?;
        writeln!(f, "sign_type         : {:02x}", self.body.sign_type)?;
        writeln!(
            f,
            "epid_group_id     : {}",
            hex::encode(self.body.epid_group_id)
        )?;
        writeln!(f, "qe_svn            : {:02x}", self.body.qe_svn)?;
        writeln!(f, "pce_svn           : {:02x}", self.body.pce_svn)?;
        writeln!(f, "xeid              : {:04x}", self.body.xeid)?;
        writeln!(f, "basename          : {}", hex::encode(self.body.basename))?;
        writeln!(f, "report_body       :\n{:?}", self.body.report_body)?;
        if let Some(sig) = &self.signature {
            write!(f, "signature_len     : {:04x}", sig.len())?;
            #[cfg(feature = "verbose")]
            write!(f, "\nsignature         : {}", hex::encode(sig))?;
        }
        Ok(())
    }
}

impl AsRef<[u8]> for SgxQuote {
    fn as_ref(&self) -> &[u8] {
        &self.bytes
    }
}

impl Into<Vec<u8>> for SgxQuote {
    fn into(self) -> Vec<u8> {
        self.bytes
    }
}

impl SgxQuote {
    /// Returns quote deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        let quote_size = bytes.len();

        // IAS quotes lack the `signature_len` and `signature` fields (they are SgxQuoteBody).
        let min_size = mem::size_of::<SgxQuoteBody>();

        if quote_size < min_size {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut body = SgxQuoteBody::default();

        body.version = reader.read_u16::<LittleEndian>()?;
        body.sign_type = reader.read_u16::<LittleEndian>()?;
        reader.read_exact(&mut body.epid_group_id)?;
        body.qe_svn = reader.read_u16::<LittleEndian>()?;
        body.pce_svn = reader.read_u16::<LittleEndian>()?;
        body.xeid = reader.read_u32::<LittleEndian>()?;
        reader.read_exact(&mut body.basename)?;
        body.report_body = SgxReportBody::from_bytes(&bytes[reader.position() as usize..])?;
        reader.set_position(min_size as u64);

        if quote_size == min_size {
            // IAS quote, no signature
            return Ok(Self {
                body,
                signature: None,
                bytes: bytes.to_owned(),
            });
        } else {
            let sig_len = reader.read_u32::<LittleEndian>()?;

            if quote_size != min_size + mem::size_of::<u32>() + sig_len as usize {
                return Err(Error::from(ErrorKind::InvalidData));
            }

            let mut sig = vec![0; sig_len as usize];
            reader.read_exact(&mut sig)?;
            Ok(Self {
                body: body,
                signature: Some(sig),
                bytes: bytes.to_owned(),
            })
        }
    }

    /// Returns quote of the currently executing enclave.
    pub fn from_enclave(user_data: &[u8]) -> Result<Self> {
        Self::from_bytes(&graphene::get_quote(user_data)?)
    }

    /// Returns hasher that can be used for building enclave quote with custom data hash
    /// contained in quote's report data. Hash used is `MessageDigest::sha512()`.
    ///
    /// # Examples
    /// ```no_run
    /// use graphene_sgx::sgx::SgxQuote;
    ///
    /// let quote = SgxQuote::hasher()
    ///     .data(&[0u8; 42])
    ///     .data(&[1u8; 10])
    ///     .build()
    ///     .unwrap();
    /// ```
    ///
    /// # Panics
    /// Panics if `MessageDigest::sha512()` fails.
    pub fn hasher() -> QuoteHasher {
        QuoteHasher {
            hasher: Hasher::new(MessageDigest::sha512()).unwrap(), // this really shouldn't fail
        }
    }
}

/// Hasher that can be used for building enclave quote with custom data hash
/// contained in quote's report data.
pub struct QuoteHasher {
    hasher: Hasher,
}

impl QuoteHasher {
    /// Add data to be hashed.
    pub fn data(mut self, data: &[u8]) -> Self {
        self.hasher.update(data).unwrap();
        self
    }

    /// Finalize hashing supplied data and convert the hasher into enclave quote.
    pub fn build(mut self) -> Result<SgxQuote> {
        SgxQuote::from_enclave(self.hasher.finish()?.as_ref())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use lazy_static::lazy_static;

    const TEST_QUOTE_HEX: &str = r#"
02000100390b00000b000a0000000000655afa33faa5b9cc5e9e241fa229
b99400000000000000000000000000000000080effff0102000000000000
000000000000000000000000000000000000000000000000000000000000
00000000000007000000000000001f00000000000000f02c8db6b9219332
c176ebb2bce4dc675a45bb7815a1bd5965eaeb064521d3d3000000000000
0000000000000000000000000000000000000000000000000000577b180d
bcdae37bd9f26444189e3ba78ad85bd03515bf26f5c4455c5284b2140000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000002a00010000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
00000000000000006385ceb874d23a87cfe9f95c432074cf2a919b701715
745696fe7b489d66f6296de87b3525e7e198c9fc24d6af3450e13c4e369a
ad84deb1673f694a16075525a802000070cf07bd37361d5b70f2d8cce014
9a0ba5930cb1e9912a23a2259f95b80186afcc792743a15529d8e2d4b7ba
1306c0f0cd03bd0bc6e2eba9914353659f24355107bcca58cf07b78950ce
b448f446b8975dfc01c65a2ff4d1ff0e68809b51105c8d25c30121d152e0
476b24d783bb5fe8f0286379222b10e3eb0626464d99184365e935c0102a
b7c7eee42cd3c9e06c7f1c7ec595000168b15822a6ea1a36954b12181b66
925a97da0a57818ff6fe37a0df97020e0f4a62ac894999ac4b7d8bd5f673
4ae45681b32d924132bbc7c0523decbd8d73db5c695d5eb34631ae098c45
2b8c3860ecdaf93bc9860ab91f8cfb4140e8afe0f11453216eecd7b6e190
94992229f2232438e18384d7d5c2c391a2dbd7bb7f989834ab767538c201
2e0e631b4b398c3f9a13dd1053e79c6268010000a8d8232ee530f7310119
beb2d88364831e28193683a46450e39fd6c718967f6897db54084a1bc6ba
b25df7d7cd47ba00723d3b4585667661fb452f98b2ee709ab862c231829d
ee23082b11c67653e170dab438242482c39327bd9322500ee05917cc4364
ee96162af8bdcd550e9091e17fc1ebad1abb2c08156075dd6887804fa80c
c532db8dd712107cc65f51e9a4df3de5e1cb0b565264a0560ff3647a3c4a
acf804b090efecb371851e1d47a558a3420272728a78b77ecc76290b3a97
277bb5998fbaf6a16f900881898f35ddef1be405c916972f35231b58b47c
5163837a82cb38ac7350e76467ce2a482181c417c2ebfcd2e03e4c45bdbc
55cbf39f9f2883cc1d783a61b71e72434c182579639cb5681c032db210f4
894023f29f39eb0acc9a8c9e22c587e82345b50809a0fba60358a8a7fb31
68e9725ccf7bf7f78d829b50f0e5048f84b3d6cb959fd51d09deca9fcba4
3e3f764c7ca3c5fc7297fc1a42f4d63238d78fcaece0abb3279b4a24eeed
bb06da84f2e8
"#;

    lazy_static! {
        pub static ref TEST_QUOTE: Vec<u8> = hex::decode(TEST_QUOTE_HEX.replace("\n", "")).unwrap();
    }

    #[test]
    fn target_info_size() {
        assert_eq!(SgxTargetInfo::size_raw(), 512);
    }

    #[test]
    fn report_size() {
        assert_eq!(SgxReport::size_raw(), 432);
    }

    #[test]
    fn parse_quote() {
        let quote = SgxQuote::from_bytes(&TEST_QUOTE);
        assert!(quote.is_ok());
        let bad_quote_bytes = [0u8; mem::size_of::<SgxQuoteBody>() - 1]; // too small
        assert!(!SgxQuote::from_bytes(&bad_quote_bytes).is_ok());
    }

    #[test]
    fn parse_mr() {
        let mr =
            parse_measurement("f02c8db6b9219332c176ebb2bce4dc675a45bb7815a1bd5965eaeb064521d3d3");
        assert!(mr.is_ok());
        let mr =
            parse_measurement("f02c8db6b9219332c176ebb2bce4dc675a45bb7815a1bd5965eaeb064521d3d");
        assert!(!mr.is_ok());
        let mr =
            parse_measurement("f02c8db6b9219332c176ebb2bce4dc675a45bb7815a1bd5965eaeb064521d3d30");
        assert!(!mr.is_ok());
        let mr = parse_measurement("");
        assert!(!mr.is_ok());
        let mr = parse_measurement("zxcv");
        assert!(!mr.is_ok());
    }

    #[test]
    fn expand_report() {
        assert!(expand_report_data(&[1u8; 0]).is_ok());
        assert!(expand_report_data(&[1u8; 1]).is_ok());
        assert!(expand_report_data(&[1u8; 63]).is_ok());
        assert!(expand_report_data(&[1u8; 64]).is_ok());
        assert!(!expand_report_data(&[1u8; 65]).is_ok());
    }
}
