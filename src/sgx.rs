//! SGX constants and types.

use byteorder::{LittleEndian, ReadBytesExt};
use hex;
use openssl::hash::{Hasher, MessageDigest};
use std::fmt::{self, Debug, Formatter};
use std::io::{Cursor, Error, ErrorKind, Read, Result};
use std::mem;

use crate::graphene;

// Enclave flags
pub const SGX_FLAGS_INITTED: u64 = 0x0000_0000_0000_0001;
pub const SGX_FLAGS_DEBUG: u64 = 0x0000_0000_0000_0002;
pub const SGX_FLAGS_MODE64BIT: u64 = 0x0000_0000_0000_0004;
pub const SGX_FLAGS_PROVISION_KEY: u64 = 0x0000_0000_0000_0010;
pub const SGX_FLAGS_EINITTOKEN_KEY: u64 = 0x0000_0000_0000_0020;
pub const SGX_FLAGS_KSS: u64 = 0x0000_0000_0000_0080;
pub const SGX_FLAGS_RESERVED: u64 = !(SGX_FLAGS_INITTED
    | SGX_FLAGS_DEBUG
    | SGX_FLAGS_MODE64BIT
    | SGX_FLAGS_PROVISION_KEY
    | SGX_FLAGS_EINITTOKEN_KEY
    | SGX_FLAGS_KSS);

// XSAVE feature request mask
pub const SGX_XFRM_LEGACY: u64 = 0x0000_0000_0000_0003;
pub const SGX_XFRM_AVX: u64 = 0x0000_0000_0000_0006;
pub const SGX_XFRM_AVX512: u64 = 0x0000_0000_0000_00E6;
pub const SGX_XFRM_MPX: u64 = 0x0000_0000_0000_0018;
pub const SGX_XFRM_RESERVED: u64 = !(SGX_XFRM_LEGACY | SGX_XFRM_AVX);

/// Extended SSA frame feature select (future functional extensions).
pub type SgxMiscSelect = u32;

/// Cryptographic key. Usually AES-128-GCM.
pub type SgxKey = [u8; 16];

/// Cryptographic key id (derivation material).
pub type SgxKeyId = [u8; 32];

/// ISV security version number.
pub type SgxIsvSvn = u16;

/// Config security version number (KSS only).
pub type SgxConfigSvn = u16;

/// Config ID (KSS only).
pub type SgxConfigId = [u8; 64];

/// CPU security version number.
pub type SgxCpuSvn = [u8; 16];

/// Service Provider ID (EPID attestation).
pub type SgxSpid = [u8; 16];

/// Quote basename (SPID for EPID quotes).
pub type SgxBasename = [u8; 32];

/// EPID group ID.
pub type SgxEpidGroupId = [u8; 4];

/// Linkability type of an EPID quote.
/// IAS verification reports of quotes generated by the same platform contain the same
/// `epidPseudonym` field if the quotes were generated using linkable signatures.
#[repr(u32)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub enum SgxQuoteSignType {
    UnlinkableSignature = 0,
    LinkableSignature = 1,
}

impl_struct! {
    /// Enclave attributes.
    pub struct SgxAttributes {
        /// Enclave flags.
        pub flags: u64,
        /// XSAVE feature request mask.
        pub xfrm: u64,
    }

    /// Enclave misc select and attributes.
    pub struct SgxMiscAttribute {
        /// Enclave attributes.
        pub secs_attr: SgxAttributes,
        /// Enclave misc select flags.
        pub misc_select: SgxMiscSelect,
    }

    /// Information specifying the target enclave for quote generation.
    /// Layout of this struct up to the `bytes` field matches `sgx_target_info_t` from the SGX SDK.
    pub struct SgxTargetInfo {
        /// MR_ENCLAVE of the target enclave.
        pub mr_enclave: SgxMeasurement,
        /// Attributes of the target enclave.
        pub attributes: SgxAttributes,
        /// Reserved, must be zero.
        pub reserved1: [u8; 2],
        /// Config SVN of the target enclave.
        pub config_svn: SgxConfigSvn,
        /// Misc select of the target enclave.
        pub misc_select: SgxMiscSelect,
        /// Reserved, must be zero.
        pub reserved2: [u8; 8],
        /// Config ID of the target enclave.
        pub config_id: SgxConfigId,
        /// Reserved, must be zero.
        pub reserved3: [u8; 384],
        /// Previous fields serialized.
        bytes: Vec<u8>,
    }

    /// Body of the cryptographic enclave report.
    /// Layout of this struct matches `sgx_report_body_t` from the SGX SDK.
    pub struct SgxReportBody {
        /// CPU security version number.
        pub cpu_svn: SgxCpuSvn,
        /// Misc select of the enclave.
        pub misc_select: SgxMiscSelect,
        /// Reserved.
        pub reserved1: [u8; 12],
        /// ISV extended product ID of the enclave.
        pub isv_ext_prod_id: SgxIsvExtProdId,
        /// Attributes of the enclave.
        pub attributes: SgxAttributes,
        /// Hash of the enclave.
        pub mr_enclave: SgxMeasurement,
        /// Reserved.
        pub reserved2: [u8; 32],
        /// Hash of the public key that signed the enclave.
        pub mr_signer: SgxMeasurement,
        /// Reserved.
        pub reserved3: [u8; 32],
        /// Config ID of the enclave.
        pub config_id: SgxConfigId,
        /// ISV product ID of the enclave.
        pub isv_prod_id: SgxProdId,
        /// ISV security version number of the enclave.
        pub isv_svn: SgxIsvSvn,
        /// Config SVN of the enclave.
        pub config_svn: SgxConfigSvn,
        /// Reserved.
        pub reserved4: [u8; 42],
        /// ISV family ID of the enclave.
        pub isv_family_id: SgxIsvFamilyId,
        /// Custom data specified by the enclave.
        pub report_data: SgxReportData,
    }

    /// Cryptographic enclave report.
    /// Layout of this struct up to the `bytes` field matches `sgx_report_t` from the SGX SDK.
    pub struct SgxReport {
        /// Report body.
        pub body: SgxReportBody,
        /// Report key ID.
        pub key_id: SgxKeyId,
        /// AES-128 CMAC of `body`.
        pub mac: SgxMac,
        /// Previous fields serialized.
        bytes: Vec<u8>,
    }

    /// Body of the enclave quote.
    pub struct SgxQuoteBody {
        /// Quote version.
        pub version: u16,
        /// Quote sign type.
        pub sign_type: u16,
        /// EPID group ID of the platform.
        pub epid_group_id: SgxEpidGroupId,
        /// Quoting Enclave's SVN.
        pub qe_svn: SgxIsvSvn,
        /// Provisioning Certification Enclave's SVN.
        pub pce_svn: SgxIsvSvn,
        /// Extended EPID group ID of the platform.
        pub xeid: u32,
        /// Quote basename.
        pub basename: SgxBasename,
        /// Cryptographic report of the enclave.
        pub report_body: SgxReportBody,
    }
}

/// Enclave quote.
#[derive(Default)]
pub struct SgxQuote {
    /// Quote body.
    pub body: SgxQuoteBody,
    /// Quote signature (absent in quotes embedded in IAS reports).
    pub signature: Option<Vec<u8>>,
    /// The whole quote serialized.
    bytes: Vec<u8>,
}

/// Size of SGX hashes (SHA-256).
pub const SGX_HASH_SIZE: usize = 32;

/// Size of SGX MACs (AES-128-CMAC).
pub const SGX_MAC_SIZE: usize = 16;

/// Size of custom data in enclave report.
pub const SGX_REPORT_DATA_SIZE: usize = 64;

/// Product ID.
pub type SgxProdId = u16;

/// ISV extended product ID.
pub type SgxIsvExtProdId = [u8; 16];

/// ISV family ID.
pub type SgxIsvFamilyId = [u8; 16];

/// Enclave cryptographic measurement.
pub type SgxMeasurement = [u8; SGX_HASH_SIZE];

/// MAC (AES-128-CMAC) data.
pub type SgxMac = [u8; SGX_MAC_SIZE];

/// Custom data in enclave report.
pub type SgxReportData = [u8; SGX_REPORT_DATA_SIZE];

/// Parse hex string as `SgxMeasurement`.
pub fn parse_measurement(hex: String) -> Result<SgxMeasurement> {
    let mut mr = SgxMeasurement::default();
    let data = hex::decode(hex).map_err(|_| Error::from(ErrorKind::InvalidInput))?;
    if data.len() != mr.len() {
        return Err(Error::from(ErrorKind::InvalidInput));
    }
    mr.copy_from_slice(&data);
    Ok(mr)
}

/// Convert byte slice into `SgxReportData` (extending with zeros if size is less than 64).
pub fn expand_report_data(user_data: &[u8]) -> Result<SgxReportData> {
    let user_data_len = user_data.len();
    if user_data_len > SGX_REPORT_DATA_SIZE {
        return Err(Error::from(ErrorKind::InvalidInput));
    }

    let mut report_data = [0; SGX_REPORT_DATA_SIZE];
    report_data[0..user_data_len].copy_from_slice(user_data);
    Ok(report_data)
}

impl Debug for SgxTargetInfo {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "")?;
        writeln!(f, "mr_enclave       : {}", hex::encode(self.mr_enclave))?;
        writeln!(f, "attributes.flags : {:02x}", self.attributes.flags)?;
        writeln!(f, "attributes.xfrm  : {:02x}", self.attributes.xfrm)?;
        #[cfg(feature = "verbose")]
        writeln!(f, "reserved1        : {}", hex::encode(self.reserved1))?;
        writeln!(f, "config_svn       : {:02x}", self.config_svn)?;
        writeln!(f, "misc_select      : {:02x}", self.misc_select)?;
        #[cfg(feature = "verbose")]
        writeln!(f, "reserved2        : {}", hex::encode(self.reserved2))?;
        write!(f, "config_id        : {}", hex::encode(&self.config_id[..]))?;
        #[cfg(feature = "verbose")]
        write!(
            f,
            "\nreserved3        : {}",
            hex::encode(&self.reserved3[..])
        )?;
        Ok(())
    }
}

impl AsRef<[u8]> for SgxTargetInfo {
    fn as_ref(&self) -> &[u8] {
        &self.bytes
    }
}

impl Into<Vec<u8>> for SgxTargetInfo {
    fn into(self) -> Vec<u8> {
        self.bytes
    }
}

impl SgxTargetInfo {
    /// Returns size of the native SGX target info struct.
    pub fn size_raw() -> usize {
        offset_of!(Self, bytes)
    }

    /// Returns target info deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() != Self::size_raw() {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut info = Self::default();

        info.bytes = bytes.to_owned();
        reader.read_exact(&mut info.mr_enclave)?;
        info.attributes.flags = reader.read_u64::<LittleEndian>()?;
        info.attributes.xfrm = reader.read_u64::<LittleEndian>()?;
        reader.read_exact(&mut info.reserved1)?;
        info.config_svn = reader.read_u16::<LittleEndian>()?;
        info.misc_select = reader.read_u32::<LittleEndian>()?;
        reader.read_exact(&mut info.reserved2)?;
        reader.read_exact(&mut info.config_id)?;
        reader.read_exact(&mut info.reserved3)?;

        Ok(info)
    }

    /// Returns target info of the currently executing enclave.
    pub fn from_enclave() -> Result<Self> {
        Self::from_bytes(&graphene::get_target_info()?)
    }
}

impl Debug for SgxReportBody {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, " cpu_svn          : {}", hex::encode(self.cpu_svn))?;
        writeln!(f, " misc_select      : {:02x}", self.misc_select)?;
        #[cfg(feature = "verbose")]
        writeln!(f, " reserved1        : {}", hex::encode(self.reserved1))?;
        writeln!(
            f,
            " isv_ext_prod_id  : {}",
            hex::encode(self.isv_ext_prod_id)
        )?;
        writeln!(f, " attributes.flags : {:02x}", self.attributes.flags)?;
        writeln!(f, " attributes.xfrm  : {:02x}", self.attributes.xfrm)?;
        writeln!(f, " mr_enclave       : {}", hex::encode(self.mr_enclave))?;
        #[cfg(feature = "verbose")]
        writeln!(f, " reserved2        : {}", hex::encode(self.reserved2))?;
        writeln!(f, " mr_signer        : {}", hex::encode(self.mr_signer))?;
        #[cfg(feature = "verbose")]
        writeln!(f, " reserved3        : {}", hex::encode(self.reserved3))?;
        writeln!(
            f,
            " config_id        : {}",
            hex::encode(&self.config_id[..])
        )?;
        writeln!(f, " isv_prod_id      : {:02x}", self.isv_prod_id)?;
        writeln!(f, " isv_svn          : {:02x}", self.isv_svn)?;
        writeln!(f, " config_svn       : {:02x}", self.config_svn)?;
        #[cfg(feature = "verbose")]
        writeln!(
            f,
            " reserved4        : {}",
            hex::encode(&self.reserved4[..])
        )?;
        writeln!(f, " isv_family_id    : {}", hex::encode(self.isv_family_id))?;
        write!(
            f,
            " report_data      : {}",
            hex::encode(&self.report_data[..])
        )
    }
}

impl SgxReportBody {
    /// Returns report body deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() < mem::size_of::<Self>() {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut body = Self::default();

        reader.read_exact(&mut body.cpu_svn)?;
        body.misc_select = reader.read_u32::<LittleEndian>()?;
        reader.read_exact(&mut body.reserved1)?;
        reader.read_exact(&mut body.isv_ext_prod_id)?;
        body.attributes.flags = reader.read_u64::<LittleEndian>()?;
        body.attributes.xfrm = reader.read_u64::<LittleEndian>()?;
        reader.read_exact(&mut body.mr_enclave)?;
        reader.read_exact(&mut body.reserved2)?;
        reader.read_exact(&mut body.mr_signer)?;
        reader.read_exact(&mut body.reserved3)?;
        reader.read_exact(&mut body.config_id)?;
        body.isv_prod_id = reader.read_u16::<LittleEndian>()?;
        body.isv_svn = reader.read_u16::<LittleEndian>()?;
        body.config_svn = reader.read_u16::<LittleEndian>()?;
        reader.read_exact(&mut body.reserved4)?;
        reader.read_exact(&mut body.isv_family_id)?;
        reader.read_exact(&mut body.report_data)?;

        Ok(body)
    }
}

impl Debug for SgxReport {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "\nreport_body:\n{:?}", self.body)?;
        writeln!(f, "key_id           : {}", hex::encode(self.key_id))?;
        write!(f, "mac              : {}", hex::encode(self.mac))
    }
}

impl AsRef<[u8]> for SgxReport {
    fn as_ref(&self) -> &[u8] {
        &self.bytes
    }
}

impl Into<Vec<u8>> for SgxReport {
    fn into(self) -> Vec<u8> {
        self.bytes
    }
}

impl SgxReport {
    /// Returns size of the native SGX report struct.
    pub fn size_raw() -> usize {
        offset_of!(Self, bytes)
    }

    /// Returns report deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() != Self::size_raw() {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut report = Self::default();

        report.bytes = bytes.to_owned();
        report.body = SgxReportBody::from_bytes(bytes)?;
        reader.set_position(mem::size_of::<SgxReportBody>() as u64);
        reader.read_exact(&mut report.key_id)?;
        reader.read_exact(&mut report.mac)?;

        Ok(report)
    }

    /// Returns report of the currently executing enclave.
    pub fn from_enclave(target_info_bytes: &[u8], user_data: &[u8]) -> Result<Self> {
        Self::from_bytes(&graphene::get_report(target_info_bytes, user_data)?)
    }
}

impl Debug for SgxQuote {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "")?;
        writeln!(f, "version           : {:02x}", self.body.version)?;
        writeln!(f, "sign_type         : {:02x}", self.body.sign_type)?;
        writeln!(
            f,
            "epid_group_id     : {}",
            hex::encode(self.body.epid_group_id)
        )?;
        writeln!(f, "qe_svn            : {:02x}", self.body.qe_svn)?;
        writeln!(f, "pce_svn           : {:02x}", self.body.pce_svn)?;
        writeln!(f, "xeid              : {:04x}", self.body.xeid)?;
        writeln!(f, "basename          : {}", hex::encode(self.body.basename))?;
        writeln!(f, "report_body       :\n{:?}", self.body.report_body)?;
        if let Some(sig) = &self.signature {
            write!(f, "signature_len     : {:04x}", sig.len())?;
            #[cfg(feature = "verbose")]
            write!(f, "\nsignature         : {}", hex::encode(sig))?;
        }
        Ok(())
    }
}

impl AsRef<[u8]> for SgxQuote {
    fn as_ref(&self) -> &[u8] {
        &self.bytes
    }
}

impl Into<Vec<u8>> for SgxQuote {
    fn into(self) -> Vec<u8> {
        self.bytes
    }
}

impl SgxQuote {
    /// Returns quote deserialized from native representation.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        let quote_size = bytes.len();

        // IAS quotes lack the `signature_len` and `signature` fields (they are SgxQuoteBody).
        let min_size = mem::size_of::<SgxQuoteBody>();

        if quote_size < min_size {
            return Err(Error::from(ErrorKind::InvalidData));
        }

        let mut reader = Cursor::new(bytes);
        let mut body = SgxQuoteBody::default();

        body.version = reader.read_u16::<LittleEndian>()?;
        body.sign_type = reader.read_u16::<LittleEndian>()?;
        reader.read_exact(&mut body.epid_group_id)?;
        body.qe_svn = reader.read_u16::<LittleEndian>()?;
        body.pce_svn = reader.read_u16::<LittleEndian>()?;
        body.xeid = reader.read_u32::<LittleEndian>()?;
        reader.read_exact(&mut body.basename)?;
        body.report_body = SgxReportBody::from_bytes(&bytes[reader.position() as usize..])?;
        reader.set_position(min_size as u64);

        if quote_size == min_size {
            // IAS quote, no signature
            return Ok(Self {
                body,
                signature: None,
                bytes: bytes.to_owned(),
            });
        } else {
            let sig_len = reader.read_u32::<LittleEndian>()?;

            if quote_size != min_size + mem::size_of::<u32>() + sig_len as usize {
                return Err(Error::from(ErrorKind::InvalidData));
            }

            let mut sig = vec![0; sig_len as usize];
            reader.read_exact(&mut sig)?;
            Ok(Self {
                body: body,
                signature: Some(sig),
                bytes: bytes.to_owned(),
            })
        }
    }

    /// Returns quote of the currently executing enclave.
    pub fn from_enclave(user_data: &[u8]) -> Result<Self> {
        Self::from_bytes(&graphene::get_quote(user_data)?)
    }

    /// Returns hasher that can be used for building enclave quote with custom data hash
    /// contained in quote's report data. Hash used is `MessageDigest::sha512()`.
    ///
    /// # Examples
    /// ```no_run
    /// use graphene::sgx::SgxQuote;
    ///
    /// let quote = SgxQuote::hasher()
    ///     .data(&[0u8; 42])
    ///     .data(&[1u8; 10])
    ///     .build()
    ///     .unwrap();
    /// ```
    ///
    /// # Panics
    /// Panics if `MessageDigest::sha512()` fails.
    pub fn hasher() -> QuoteHasher {
        QuoteHasher {
            hasher: Hasher::new(MessageDigest::sha512()).unwrap(), // this really shouldn't fail
        }
    }
}

/// Hasher that can be used for building enclave quote with custom data hash
/// contained in quote's report data.
pub struct QuoteHasher {
    hasher: Hasher,
}

impl QuoteHasher {
    /// Add data to be hashed.
    pub fn data(mut self, data: &[u8]) -> Self {
        self.hasher.update(data).unwrap();
        self
    }

    /// Finalize hashing supplied data and convert the hasher into enclave quote.
    pub fn build(mut self) -> Result<SgxQuote> {
        SgxQuote::from_enclave(self.hasher.finish()?.as_ref())
    }
}
